package 
{
	import flash.display.Sprite;
	import flash.events.Event;
	import flash.text.TextField;
	import flash.text.TextFormat;
	
	/**
	 * Show how binary operators work.
	 * @author tronster
	 */
	public class Main extends Sprite 
	{
		private var results:TextField;
		
		
		/// CTOR
		public function Main():void 
		{
			// Oh yeah, that's right there is allocating of a textfield but it's okay
			// because there are no display list operations occuring yet.
			results	= new TextField();

			var fmt	:TextFormat = new TextFormat("Courier New", 18, 0x0, true );
			results.defaultTextFormat = fmt;
			
			if (stage) init();
			else addEventListener(Event.ADDED_TO_STAGE, init);
		}
		
		private function init(e:Event = null):void 
		{
			removeEventListener(Event.ADDED_TO_STAGE, init);

			// Now that the Main sprite is on the display list and a valid stage exists,
			// setup the dimensions of the results and properly attach it to be seen.
			results.width = stage.stageWidth;
			results.height = stage.stageHeight;
			results.multiline = true;
			addChild( results );
			
			// Test with the AND operator
			/*
			out( "0x1 & 0x1", (0x1 & 0x1) );
			out( "0x2 & 0x1", (0x2 & 0x1) );
			out( "0x1 & 0x2", (0x1 & 0x2) );
			out( "0x2 & 0x2", (0x2 & 0x2) );
			out( "0xf & 0x1", (0xf & 0x1) );
			out( "0x1 & 0x2 & 0x3", (0x1 & 0x2 & 0x3) );
			out( "0x1 & 0xf & 0x3", (0x1 & 0xf & 0x3) );
			
			// Test with the OR operator
			out( "0x1 | 0x1", (0x1 | 0x1) );
			out( "0x2 | 0x1", (0x2 | 0x1) );
			out( "0x1 | 0x2", (0x1 | 0x2) );
			out( "0x2 | 0x2", (0x2 | 0x2) );
			out( "0xf | 0x1", (0xf | 0x1) );
			out( "0x1 | 0x2 | 0x3", (0x1 | 0x2 | 0x3) );
			out( "0x1 | 0xf | 0x3", (0x1 | 0xf | 0x3) );

			// Test with the XOR operator
			out( "0x1 ^ 0x1", (0x1 ^ 0x1) );
			out( "0x2 ^ 0x1", (0x2 ^ 0x1) );
			out( "0x1 ^ 0x2", (0x1 ^ 0x2) );
			out( "0x2 ^ 0x2", (0x2 ^ 0x2) );
			out( "0xf ^ 0x1", (0xf ^ 0x1) );
			out( "0x1 ^ 0x2 ^ 0x3", (0x1 ^ 0x2 ^ 0x3) );
			out( "0x1 ^ 0xf ^ 0x3", (0x1 ^ 0xf ^ 0x3) );

			// Test with the NOT operator
			out( "~0x1", ~0x1 );
			out( "~0xf", ~0xf );
			out( "~0x33", ~0x33 );
			*/


			out( "a: ", 0x80000000 >> 1 );
			
			// Test with the SHIFT RIGHT operator
			out( "0x1 >> 0x1", (0x1 >> 0x1) );
			out( "0x2 >> 0x1", (0x2 >> 0x1) );
			out( "0x1 >> 0x2", (0x1 >> 0x2) );
			out( "0x2 >> 0x2", (0x2 >> 0x2) );
			out( "0xf >> 0x1", (0xf >> 0x1) );
			out( "0x1 >> 0x2 >> 0x3", (0x1 >> 0x2 >> 0x3) );
			out( "0x1 >> 0xf >> 0x3", (0x1 >> 0xf >> 0x3) );

			/*
			// Test with the SHIFT LEFT operator
			out( "0x1 << 0x1", (0x1 << 0x1) );
			out( "0x2 << 0x1", (0x2 << 0x1) );
			out( "0x1 << 0x2", (0x1 << 0x2) );
			out( "0x2 << 0x2", (0x2 << 0x2) );
			out( "0xf << 0x1", (0xf << 0x1) );
			out( "0x1 << 0x2 << 0x3", (0x1 << 0x2 << 0x3) );
			out( "0x1 << 0xf << 0x3", (0x1 << 0xf << 0x3) );
			
			*/
		}
		
		/// Output to the text field 
		private function out( s1:String, s2:* ):void
		{
			// Add text and a newline
			results.appendText( s1 + " = " + String(s2) + "\n" );
		}
	}
	
}